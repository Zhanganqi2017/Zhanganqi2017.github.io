[{"title":"githubPage 配置域名","date":"2020-04-20T16:33:06.000Z","path":"2020/04/21/githubPage-配置域名/","text":"买域名国内购买域名可在阿里云上购买 域名解析之后需要在阿里云控制台操作域名，对域名进行解析操作。选择想到操作的域名，如点击解析设置，跳转页面。点击新手引导，在弹窗输入githubname.github.io的ip。 ip 获取方式在电脑CMD 输入，ping githubName.github.io,变可得到 github 设置打开githubpage的项目-setting -拉后面-在custom domain 输入域名 以下配置等同上方github仓库配置 若是为了配置hexo 博客的域名，可在source下创建CNAME文件，并在文件内写入域名即可。（在source上创建文件，在每次生成文件，部署到github后都会在根目录）","comments":true,"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://zhanganqi2017.github.io/tags/杂谈/"}]},{"title":"react 基础语法","date":"2020-04-14T11:04:35.000Z","path":"2020/04/14/react-基础语法/","text":"react组件、状态","comments":true,"tags":[{"name":"React","slug":"React","permalink":"https://zhanganqi2017.github.io/tags/React/"}]},{"title":"vue基本语法","date":"2019-07-09T15:44:51.000Z","path":"2019/07/09/vue基本语法/","text":"Vue 基本语法模板语法1234567- mustache语法：&#123;&#123;msg&#125;&#125;- html 赋值：v-html=\"\"- 绑定属性：v-bind：id=\"\"- 使用表达式：&#123;&#123;ok?'yes'：'no'&#125;&#125;- 文本赋值：v-text=“”- 指令：v-if=\"\",v-show=\"\"(两者的区别是，v-if 当值为 false 时,页面上没有该标签生成, 但是 v-show 无论值为 true 还是 false , 页面都会相对应的 dom 结点)- 过滤器：&#123;&#123;a|b&#125;&#125; 和 v-bind:id=\"a|b\" Class 和 Style 绑定 方式一：对象语法 1v-bind:class=\"&#123;active:isActive,'text-danger':hasError&#125;\" 方式二：数组语法 1v-bind:class=\"[activeClass,errorClass]\" 方式三：style 绑定-对象语法 1v-bind:style=\"&#123;color:activeColor,fontSize:fontSize+'px'&#125;\" 条件渲染 v-if v-else-if v-else v-show v-cloak v-cloak 讲解当网络不好或者数据量大的时候，页面在渲染的过程中会闪烁 mustache 标签。12345678910111213141516// 为了便于演示效果，将 vue 实例延迟 2s&lt;div id=\"app\"&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;scirpt&gt; setTimeout(()=&gt;&#123; new Vue(&#123; el:'#app', data()&#123; return &#123; msg:\"hello\" &#125; &#125; &#125;) &#125;,2000)&lt;/script&gt; 因为实例延迟了 2s ，所以页面渲染，结点的显示会由 闪烁为 hello。 为了解决 mustache 闪烁为问题，为了用户有更好的体验，vue 加入了 v-cloak，在与css:[v-cloak]{display:none} 的配合，可以隐藏未被编译的 mustache 标签直到实例准备完毕。实例化完后，v-cloak 会被自动删除，标签即可显示。 123456789101112131415161718192021// 为了便于演示效果，将 vue 实例延迟 2s&lt;style type=\"text/css\"&gt; [v-cloak]&#123; display:none !import; &#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;scirpt&gt; setTimeout(()=&gt;&#123; new Vue(&#123; el:'#app', data()&#123; return &#123; msg:\"hello\" &#125; &#125; &#125;) &#125;,2000)&lt;/script&gt; 因为加入了 v-cloak ，所以前2s 页面空白，2s 后，页面出现 hello。（加入 import 的原因是，防止 v-cloak 的 display 属性被更高层级的 css 覆盖） vue 事件处理器 v-on:click=”functionName” 或 @click=”functionName” 给事件指定属性 v-on:click.stop(阻止事件冒泡) v-on:click.stop.prevent(阻止默认事件执行) v-on:click.self(指向事件对象本身) v-on:click.once(事件只能执行一次) 给事件指定修饰符 v-on:keyup.enter(表示按下 enter 键) enter tab delete(捕获删除 和 退格 键) esc up down left right Vue 组件组件就是自定义的 html 元素。 全局组件和局部组件 父子组件通讯 - 数据传递(通过 props 和 emit) Slot 组件使用步骤一：创建构建起 Vue.extend()步骤二：注册组件 Vue.component()步骤三：使用组件 组件要挂载在某个实例上，否则不会生效 创建全局组件1234567891011// 1.创建组件构造器var mycomponent = Vue.extend(&#123; template:'&lt;div&gt;我是组件&lt;/div&gt;'&#125;)// 2. 注册全局组件Vue.component('my-componnet',mycomponent);// 3.挂载组件new Vue(&#123; el:\"#app\", component:my-component&#125;) 父组件通过 prop 与子组件进行通信123456789101112131415&lt;div&gt; &lt;child message=\"hello我是父组件\"&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt;// 注册子组件Vue.componnet(&#123; //声明 props props:['message'], template:'&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;'&#125;)// 创建 vue 实例new Vue(&#123; el:\"#app\"&#125;)&lt;/script&gt; jieshu","comments":true,"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://zhanganqi2017.github.io/tags/Vuejs/"}]},{"title":"ARIA","date":"2019-06-02T07:56:05.000Z","path":"2019/06/02/ARIA/","text":"ARIA ARIA 全称为 Accessible Rich Internet Applications，它表现为一组属性，适用于可访问性的一份标准。它的定义包含各种设备访问，各种环境，各种人群访问的友好性。 ARIA 是以交互形式来标注各种元素的一类属性。交互性是跟直接中的“控件”十分相似。 ARIA 给 HTML 添加了一个核心的属性就是 role。开发者可以通过给控件添加 role 角色。 以 ARIA 角色为中心，可以将 ARIA 分为三类： Widge 角色：主要是各种可交互的控件 structure 结构角色：文档的结构 window 角色：弹出的窗体 Widge 角色Widege 觉得跟我们桌面开发中的控件类似，它表示一个可交互的组件。我们可以通过 HTML 属性变化来理解 JavaScript 组件的状态。 这些 role 可以出现在任何一个 HTML 元素之上，同时要注意，这些 ARIA 属性，不会真实地改变任何一个元素的行为，需要用 JavaScript 编写相应的逻辑。 structure 角色结构角色跟 HTML5 中不少新标签作用重合，建议优先使用 HTML5 标签。这部分角色的作用类似于语义化标签，但内容稍微有些不同。 window 角色有些元素表示“新窗口”，这时候，会用到 window 角色。window 系角色： window dialog alertdialog","comments":true,"tags":[{"name":"HTML","slug":"HTML","permalink":"https://zhanganqi2017.github.io/tags/HTML/"}]},{"title":"async","date":"2019-05-27T09:55:35.000Z","path":"2019/05/27/async/","text":"作为一门单线程的语言，刚学习 JavaScript 语言的时候，我曾怀疑过 JavaScript 在处理 ajax 数据请求，文件解析等过程效率会很低，而且在执行这些任务较大的代码中，会严重阻塞后面代码的执行。但让人兴奋的是，这门语言具有异步加载的特性。 事件循环1. 含义javascript 提供一种机制来处理程序中多个块的执行，且每个执行块都调用了 JavaScript 引擎，这种机制被称为事件循环。 2. setTimeoutsetTimeout 在不清楚它的调用机制的时候，可能会容易掉坑。一定要清楚的是，setTimeout 执行的时候，并没有把回调函数放入事件循环队列中，它做的事情只是设置一个定时器，当时间到时后，环境才会把回调函数加入到事件循环队列中 考虑下面的例子12345setTimeout(function()&#123; console.log(\"setTimeout\")&#125;,0)console.log(\"console\")// console,setTimeout 根据 setTimeout 的执行机制，这个例子的先后执行顺序就一目了然了。即便 setTimeout 的定时器时间为0，但是因为事件循环机制，且考虑到浏览器实行的延迟作用，setTimeout 依旧还是会慢与外界的 console。 回调1.含义回调是编写和处理 JavaScript 程序异步逻辑最常用的方式。 2.嵌套回调和链式回调考虑:123456789listen('click',function handle()&#123; setTimeout(function request()&#123; ajax('http:XXX',function response(data)&#123; if(data.code===200)&#123;code...&#125; else&#123;code...&#125; &#125;) &#125;, 500)&#125;) 在我初学 javascript 的时候，常写这种函数嵌套在一起构成一条链的代码，因为它能按照我们想要执行的顺序执行，但是这种代码在嵌套多层的时候是很容易让人混乱的，这种代码常常被称为回调地狱 不用嵌套将上述代码重写，可写为:1234567891011listen('click',handle)function handle()&#123; setTimeout(request,500)&#125;function request()&#123; ajax('http:XXX',response)&#125;function response(data)&#123; if(data.code===200)&#123;code...&#125; else&#123;code...&#125;&#125; 3.总结通过上述例子我们可以初步的理解回调的意义，下面将会讲解异步最常使用的 Promise。 Promise1.基础知识Promise（译为期望，期待），是一种封装和组合未来值的易于复用的机制； 1.1信任问题 未能传递参数/环境值（如果使用多个参数调用 resolve（） 或者 reject（） 第一个参数之后的所有参数都会被默认忽略 吞掉错误或异常：在创建 promise 或查看决议的过程中，出现 typeerror 或者 referenceerror，那么这个异常会被捕获，并且会使这个 promise 被拒绝 是可信任的 promise ：1）向 promise.resolve() 传递非 promise 非 thenable 会得到用这个值填充的 promise 2）向 promise.resolve() 传递一个真正的 promise 只会返回同一个 promise 1.2 链式流调用 then() 时的完成处理函数或拒绝处理函数，如果抛出异常，都会导致链中下一个 promise 因为这个异常而立即被拒绝。如果没有传入拒绝处理函数，那么会使用默认拒绝处理函数。（默认拒绝处理函数，只是把错误重新抛出，使链接的 promise 用同样的错误理由拒绝，从本质来说，这使得错误可以继续沿着 promise 链传播下去，直到遇到显式定义的拒绝函数。） 注：当给 promise.resolve() 传递的是 promise 或是一个 thenable ，promise.resolve() 会直接返回接收到的 promise,或展开接收到的 thenable 的值。但 promise.reject() 不会像 resolve() 一样进行展开。如果向 reject() 传入 promise/thenable 会将此值原封不动的设置为拒绝理由。 1.3 错误处理对于只有 reject 的then，可以直接使用 .catch() 1.4 promise 模式 Promise.all([]) 接收一个数组，每个元素都是一个 Promise，主 Promise 在且仅在所有的成员 promise 都完成后才会完成 Promise.race([]) 这种模式成为 门闩，竞态。一旦有一个 promise 决议为完成，Promise.race([]) 就会完成。一旦有任何一个 promise 决议为拒绝，他就会拒绝。（若数组为空，永远不会决议） Promise.none([]) 与all([]) 相反，当所有的 promise 都是拒绝的时候，即拒绝转换为完成值。 Promise.any([]) 只需要有一个完成，即可转化为完成值 Promise.first([]) 只要第一个 promise 完成就会忽略后续的任何拒绝和完成 Promise.last([]) 只要最后一个 promise 完成就会忽略后续的任何拒绝和完成。2.语法下面代码创造了一个 Promise 实例12345678const myPromise = new Promise(function(resolve,reject)&#123; // ...code if(/异步执行成功/) &#123; resolve(value) &#125; else &#123; //异步执行失败 reject(error) &#125; resolve函数的作用是，当 Promise 的状态由未完成转变为成功时调用的函数，reject函数的作用是，当 Promise 的状态由未来城转变为失败时调用的函数Promise 实例生成后，可以使用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数123456myPromise.then(function(value)&#123; // success &#125;,function(error)&#123; //error &#125;) then的方法可以接收两个参数，第一个回到函数是当 Promise 状态变为成功 resolved 时调用，第二个回调函数是当 Promise 状态变为失败 rejected 时调用，第二个参数是可选的，非必须的 3.实战练习根据上面的事件循环机制，以及 Promise 的语法，考虑下方代码:1234567891011let myPromise = new Promise(function(resolve,reject)&#123; console.log(\"promise\"); resolve()&#125;)myPromise.then(function()&#123; console.log(\"resolved.\")&#125;)console.log(\"consolelog\")// promise//consolelog//resolved. 上面代码中，Promise 新建后立即执行，所以首先输出的是 “Promise”，然后，then 方法指定回调函数，将当前脚本所有同步任务执行完之后再调用，所以 ，然后输出 “consolelog”，最后执行 then ，输出“resolved.” 进而再考虑下面代码:123456789setTimeout(function()&#123;console.log(\"setTimeout\")&#125;,0)let myPromise = new Promise(function(resolve,reject)&#123; console.log(\"promise\"); resolve()&#125;).then(function()&#123; console.log(\"resolved.\")&#125;)console.log(\"consolelog\")// promise -&gt; consolelog -&gt; resolved. -&gt; setTimeout 这段代码即是上面代码加上 setTimeout ，原理是相同的，因为 setTimeout 存在延迟，即便延迟时间为0，它都不属于 Promise 所在的同步任务事件队列中，所以，setTimeout 会在最后执行。 思考题如何实现下方代码连续打印出 0，1，2.。。9123456for (var i=0;i&lt;10;i++) &#123; setTimeout(()=&gt;&#123; console.log(i) &#125;,1000)&#125;// 打印出 10 个 10 方案一：setTimeout 传入 i，保持 i12345for (var i=0;i&lt;10;i++) &#123; setTimeout((i)=&gt;&#123; console.log(i) &#125;,1000,i)&#125; 方案二：将 var 修改为 let，因为 let 会重新定义一个全新的 i12345for (let i=0;i&lt;10;i++) &#123; setTimeout(()=&gt;&#123; console.log(i) &#125;,1000)&#125; 方案三：使用立即函数调用的方式12345for (var i=0;i&lt;10;i++) &#123; (function(i)&#123; setTimeout(()=&gt;&#123;console.log(i)&#125;,1000) &#125;)(i);&#125; 总结 本文主要讲解了 javascript 的事件循环机制，代码自上而下执行过程中，是存在异步执行的过程的，但在当前所有同步任务的执行依旧是自上而下的。另外，本文主要讲解了 Promise 的主要用法","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhanganqi2017.github.io/tags/JavaScript/"}]},{"title":"类型和值","date":"2019-05-24T15:09:00.000Z","path":"2019/05/24/type-value/","text":"类型概念：对语言引擎和开发者来说，类型是值得内部特征，它定义了值得行为，以使其区别于其他值 内置类型 null 空值 undeined 未定义 boolean 布尔值 number 数字 string 字符串 symbol 符号 object 对象 注：除了对象外，其他都是基本类型。使用 typeof 检查数据类型时，注意 typeof null == object。 所以我们需要使用复合条件来检测 null类型1234var a = null;(!a &amp;&amp; typeof a === \"object\")或String(a) 值数组需要注意的点： 创建“稀疏”数组时，空白单元会被赋值为 undefined 12345var a = [];a[0] = 1;a[2] = 3;a.length; //3a[1]; // undefined 数组通过数字进行索引，但也可以包含字符串键值和属性（但是这些并不计算在数组长度内） 12345var a = [];a[0] = 1;a[1] = 2;a[\"foo\"] = \"foo\";a.length; // 2 如果字符串键值能够被强制转换为十进制数字的话，它就会被当做数字索引来处理。 123var a = [];a[\"13\"] = 1;a.length; //14 类数组arguments 对象是一个类数组，通常通过 indexOf（），concat（），forEach（） 来将类数组转换成真正的数组； 字符串字符串也是一个类数组数据，它具备着 length ，indexOf（）等方法。 数字JavaScript 中的数字类型是基于 IEEE 754 标准来实现的，该标准通常也被称为 “浮点数”。javascript使用的是“双精度”格式。（64位的二进制） 特别大和特别小的数字默认用指数格式表示。与 toExponential（）函数的输出结果相同 123var a = 5E10;a; //5000000000a.toExonential(); // 5e+10 数字值可以使用 Number 对象进行封装，所以可以使用 Number.prototype 中的方法。 tofixed() 指定小数部分的显示位数； toPrecision() 指定有效数位的显示位数； 0.1 + 0.2 ！== 0.3 通过设置一个误差范围值，来判断左右两边是否相等。通常称为“机器精度”，对于 JavaScript 来说，这个值是2^-52（2.220446049250313e-16）。从 es6 开始，该值定义在 Number.EPSILON 中。 最大的浮点数大约是 1.798e+308，它定义在 Number.MAX_VALUE 中。 最小的浮点数定义在 Number.MIN_VALUE 中，大约是5e-325，他不是负数，但无限接近于0！ 能够被安全呈现的最大整数是 2^53 - 1，即9007199254740991，被定义为 Number.MAX_SAFE_INTEGER. 最小的整数是-9007199254740991，被定义为 Number.MIN_SAFE_INTEGER。 整数检测 Number.isInteger() 1Number.isInteger(42.2); // false 检测是否是安全的整数。 Number.isSafeInteger() setTimeout() 函数返回一个数值（计时器间隔的唯一标识符，用来取消计时） NAN 不是数字的数字，仍然是数字类型，是唯一一个非自反的值。使用 isNaN（）函数来判断是否是 NaN 零值，JSON.stringify(-0) 返回 “0”，JSON.parse(“-0”) 返回-0。 判断 -0，使用isNegZero（） 特殊等式：es6 新加入一个工具方法 Object.is() 来判断两个值是否绝对相等。 注：var a = 42. 这种表示方式是可以的。 值和引用 简单值总是通过值复制的方式来赋值/传递，包括null，undefined，bollean，number，string，symbol 复合值–对象，通过引用复制的方式来赋值/传递值，包括数组，对象","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhanganqi2017.github.io/tags/JavaScript/"}]},{"title":"prototype","date":"2019-05-23T15:13:07.000Z","path":"2019/05/23/prototype/","text":"原型1.1 [[Prototype]]JavaScript 中对象有一个特殊的 [[Prototype]] 内置属性。其实就是对于其他对象的引用 1.1.1 Object.prototype所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype 1.1.2 属性设置和屏蔽对于代码：myobj.foo = &quot;bar&quot; 如果 myobj 对象中包含名为 foo 的属性，这条赋值语句只会修改已有的属性值 如果 foo 不是直接存在 myobj 中，原型链就会被遍历，类似于 [[get]] 操作。如果原型链上找不到 foo 属性，foo 就会被直接添加到 myobj 如果 foo 存在原型链中，则处理方式有三种 如果在原型链层上存在 foo 属性，并且没有被标记为只读（writable：false），那么就会在 myobj 上添加一个名为 foo 的新属性，它是屏蔽属性。 如果在原型链上存在 foo ，但是被标记为只读，则无法修改已有属性或是在 myobj 上创建屏蔽属性。且如果是运行在严格模式下，代码会抛出错误。否则，就会忽略这条赋值语句。 如果在原型链上存在 foo 属性并且它是一个 setter ，那么一定会调用这个 setter。foo 不会被添加到 myobj，也不会重新定义 foo 这个 setter。 1.2 “类” Object.getPrototypeOf(a) 用于得到 a 的原型链上的原型 1.3 （原型）继承将 a.prototype 关联到 b.prototype 的两种方法 a.prototype = Object.create(b.prptotype) Object.setPrototypeOf(a.prototype,b.prototype) 判断对象是否是实例的方式 a instanceof Foo Foo.prototype.isPrototypeOf(a) Object.getPrototypeOf(a) === Foo.prototype [[prototype]]实现过程123456789Object.definePrototype(Object.prototype,\"__proto__\",&#123; get:function()&#123; return Object.getPrototypeOf(this) &#125;, set:function()&#123; Object.setPrototypeOf(this,o) return o; &#125;&#125;) 1.4 关联 obj.hasOwnPrototype(“a”) 判断对象 obj 是否存在属性或方法 a，不检查原型链","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhanganqi2017.github.io/tags/JavaScript/"}]},{"title":"scope","date":"2019-05-21T15:21:00.000Z","path":"2019/05/21/scope/","text":"作用域 理解作用域，我们需要知道与作用域一起合作搭档的伙伴有 “引擎”，“编译器”。引擎是用来负责整个 JavaScript 程序编译及执行的过程。编译器是负责语法分析及代码生成等工作。作用域是负责收集并维护由所有声明的标识符（变量)组成的一系列查询。 词法作用域简单的说，词法作用域就是定义在词法阶段的作用域。其中涉及两种欺骗词法的方式：eval，with。 eval：可以接收一个字符串为参数，并将其中的内容视为好像就写存在程序中这个位置的代码。会修改原本存在的词法作用域。 with：通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。会新创建一个作用域。 注：不建议在代码中使用 eval 和 with ，因为会破坏编译时的优化。","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhanganqi2017.github.io/tags/JavaScript/"}]},{"title":"字符串最长类","date":"2019-05-09T14:52:57.000Z","path":"2019/05/09/String-long-question/","text":"字符串常见考题就是求 XX 条件下的最大长度。 解决这类问题的常用步骤就是： 怎么判断当前情况下是否满足 XX 条件 满足条件下，怎么办；不满足条件怎么办 记录当前长度与最大的关系 原题解析【leetcode 3. 无重复字符的最长子串】 给定一个字符串，请你找出其中不含有重复&gt; 字符的 最长子串 的长度。示例 1:123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 解析： 首先这题给我们的是一个字符串，然后条件就是“无重复”，求最长子串长度。 要判断一个字符是否重复出现:根据数组 indexOf 的方法，判断返回值，大于等于0，说明当前字符在之前出现过了，等于-1，说明没有出现。由此，我们可把传入的字符串转成成数组。 若重复出现，则把当前子字符串的起始位置重新安排，变为其重复位置的索引的下一位。由此，我们需要记录下当前字符上一次出现的位置。 若没有出现，则无需处理。 判断当前子字符串长度与我们存储的最大长度的关系。更正最大长度。123456789101112131415161718192021222324/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; var max=0; var arr=s.split(\"\"); var start = 0,end = 1; var len = arr.length; if(len&lt;=1) &#123; return len; &#125; let union = function(arr,start,end) &#123; var mysliceArr = arr.slice(start,end); return mysliceArr.indexOf(arr[end]);; &#125; while(end&lt;len) &#123; var index = union(arr,start,end) start = start+index+1; max = Math.max(end-start+1,max) end++; &#125; return max;&#125;;","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"https://zhanganqi2017.github.io/tags/算法/"}]}]